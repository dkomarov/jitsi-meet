<html itemscope itemtype="http://schema.org/Product" prefix="og: http://ogp.me/ns#" xmlns="http://www.w3.org/1999/html">
  <head>
    <!--#include virtual="head.html" -->
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <meta name="theme-color" content="#2A3A4B">
    <!--#include virtual="base.html" -->

    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="stylesheet" href="css/all.css">
    <link rel="stylesheet" href="css/custom-icon.mods.css">
    <link
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    rel="stylesheet"
    type="text/css"
    />

    <!--#include virtual="fonts.html"-->
    <link rel="manifest" id="manifest-placeholder">

    <script>
        function contextRoot(pathname) {
            const contextRootEndIndex = pathname.lastIndexOf('/');

            return (
                contextRootEndIndex === -1
                ? '/'
                : pathname.substring(0, contextRootEndIndex + 1)
            );
        }
        window.EXCALIDRAW_ASSET_PATH = 'libs/';
        // Dynamically generate the manifest location URL. It must be served from the document origin, and we may have
        // the base pointing to the CDN. This way we can generate a full URL which will bypass the base.
        document.querySelector('#manifest-placeholder').setAttribute('href', window.location.origin + contextRoot(window.location.pathname) + 'manifest.json');

        document.addEventListener('DOMContentLoaded', () => {
            if (!JitsiMeetJS.app) {
                return;
            }

            JitsiMeetJS.app.renderEntryPoint({
                Component: JitsiMeetJS.app.entryPoints.APP
            })

            const isEmbedded = () => {
                try {
                    return window.self !== window.top;
                } catch (e) {
                    return true;
                }
            };

            const isElectron = navigator.userAgent.includes('Electron');
            const shouldRegisterWorker = !isElectron && !isEmbedded() && 'serviceWorker' in navigator;

            if (shouldRegisterWorker) {
                navigator.serviceWorker
                    .register(window.location.origin + contextRoot(window.location.pathname) + 'pwa-worker.js')
                    .then(reg => {
                        console.log('Service worker registered.', reg);
                    })
                    .catch(err => {
                        console.log(err);
                    });
            }
        });
    </script>
    <script>
        // IE11 and earlier can be identified via their user agent and be
        // redirected to a page that is known to have no newer js syntax.
        if (window.navigator.userAgent.match(/(MSIE|Trident)/)) {
            var roomName = encodeURIComponent(window.location.pathname);
            window.location.pathname = 'static/recommendedBrowsers.html';
        }

        window.indexLoadedTime = window.performance.now();
        console.log("(TIME) index.html loaded:\t", indexLoadedTime);
        window.addEventListener('load', function() {
            window.loadedEventTime = window.performance.now();
            console.log("(TIME) window loaded event:\t", loadedEventTime);
        });

        // XXX the code below listeners for errors and displays an error message
        // in the document body when any of the required files fails to load.
        // The intention is to prevent from displaying broken page.
        var criticalFiles = [
            "config.js",
            "utils.js",
            "do_external_connect.js",
            "interface_config.js",
            "lib-jitsi-meet.min.js",
            "app.bundle.min.js",
            "all.css"
        ];
        var loadErrHandler = function(e) {
            var target = e.target;
            // Error on <script> and <link>(CSS)
            // <script> will have .src and <link> .href
            var fileRef = (target.src ? target.src : target.href);
            if (("SCRIPT" === target.tagName || "LINK" === target.tagName)
                && criticalFiles.some(
                    function(file) { return fileRef.indexOf(file) !== -1 })) {
                window.onload = function() {
                    // The whole complex part below implements page reloads with
                    // "exponential backoff". The retry attempt is passes as
                    // "rCounter" query parameter
                    var href = window.location.href;

                    var retryMatch = href.match(/.+(\?|&)rCounter=(\d+)/);
                    var retryCountStr = retryMatch ? retryMatch[2] : "0";
                    var retryCount = Number.parseInt(retryCountStr);

                    if (retryMatch == null) {
                        var separator = href.indexOf("?") === -1 ? "?" : "&";
                        var hashIdx = href.indexOf("#");

                        if (hashIdx === -1) {
                            href += separator + "rCounter=1";
                        } else {
                            var hashPart = href.substr(hashIdx);

                            href = href.substr(0, hashIdx)
                                + separator + "rCounter=1" + hashPart;
                        }
                    } else {
                        var separator = retryMatch[1];

                        href = href.replace(
                            /(\?|&)rCounter=(\d+)/,
                            separator + "rCounter=" + (retryCount + 1));
                    }

                    var delay = Math.pow(2, retryCount) * 2000;
                    if (isNaN(delay) || delay < 2000 || delay > 60000)
                        delay = 10000;

                    var showMoreText = "show more";
                    var showLessText = "show less";

                    document.body.innerHTML
                        = "<div style='"
                        + "position: absolute;top: 50%;left: 50%;"
                        + "text-align: center;"
                        + "font-size: medium;"
                        + "font-weight: 400;"
                        + "transform: translate(-50%, -50%)'>"
                        + "Uh oh! We couldn't fully download everything we needed :("
                        + "<br/> "
                        + "We will try again shortly. In the mean time, check for problems with your Internet connection!"
                        + "<br/><br/> "
                        + "<div id='moreInfo' style='"
                        + "display: none;'>" + "Missing " + fileRef
                        + "<br/><br/></div>"
                        + "<a id='showMore' style='"
                        + "text-decoration: underline;"
                        + "font-size:small;"
                        + "cursor: pointer'>" + showMoreText + "</a>"
                        + "&nbsp;&nbsp;&nbsp;"
                        + "<a id ='reloadLink' style='"
                        + "text-decoration: underline;"
                        + "font-size:small;"
                        + "'>reload now</a>"
                        + "</div>";

                    var reloadLink = document.getElementById('reloadLink');
                    reloadLink.setAttribute('href', href);

                    var showMoreElem = document.getElementById("showMore");
                    showMoreElem.addEventListener('click', function () {
                            var moreInfoElem
                                    = document.getElementById("moreInfo");

                            if (showMoreElem.innerHTML === showMoreText) {
                                moreInfoElem.setAttribute(
                                    "style",
                                    "display: block;"
                                    + "color:#FF991F;"
                                    + "font-size:small;"
                                    + "user-select:text;");
                                showMoreElem.innerHTML = showLessText;
                            }
                            else {
                                moreInfoElem.setAttribute(
                                    "style", "display: none;");
                                showMoreElem.innerHTML = showMoreText;
                            }
                        });

                    window.setTimeout(
                        function () { window.location.replace(href); }, delay);

                    // Call extra handler if defined.
                    if (typeof postLoadErrorHandler === "function") {
                        postLoadErrorHandler(fileRef);
                    }
                };
                window.removeEventListener(
                    'error', loadErrHandler, true /* capture phase */);
            }
        };
        window.addEventListener(
            'error', loadErrHandler, true /* capture phase type of listener */);

        // var latestJitsiVersion = 10314 (June 2025); // *** UPDATE in MVP project!! ***

        console.log("Jitsi Meet version: 10431 (July 2025)");

        window.parent.postMessage("Jitsi Meet version: 10431 (July 2025)", '*')
       
        // ============ custom colors, font-size msg
        //   window.addEventListener('message', function(event) {

        //     if (typeof event.data === "string" && event.data.includes('Selected jitsi-icon color: ')) {

		// 				console.log("Message received from the parent: " + event.data); // Message received from parent


        //     // Get all elements with the class ".jitsi-icon"
        //     var elements = document.querySelectorAll('.jitsi-icon-default svg:not(.settings-button-small-icon svg, #participant-connection-indicator svg, #mic-disabled, #toggleFilmstripButton svg)');  // aria-label=Moderator

		// 					// Loop through each element and set styles
		// 					elements.forEach(function(element) {
		// 						// element.style.fill = event.data.split(': ')[1]; // Set background color                         
        //                         element.classList.add(event.data.split(': ')[1]);
		// 					});

		// 				// Get all elements with the class ".jitsi-icon"
        //     var textElements = document.querySelectorAll('.jitsi-icon-default svg tspan:not(.settings-button-small-icon svg)');

		// 									// Loop through each element and set styles
		// 					textElements.forEach(function(element) {
		// 						// element.style.fill = event.data.split(': ')[1] + ' !important'; // Set background color                                      
        //                         element.classList.add(event.data.split(': ')[1]);

		// 					});
        //     }

		// 	if (typeof event.data === "string" && event.data.includes('Selected jitsi-icon size: ')) {


        //     // Get all elements with the class ".jitsi-icon"
        //     var elements = document.querySelectorAll('.jitsi-icon-default svg:not(.settings-button-small-icon svg, #participant-connection-indicator svg, #mic-disabled, #toggleFilmstripButton svg)');  // aria-label=Moderator
		// 				   let size_class = {
        //                         36: 'size-small',
        //                         48: 'size-medium',
        //                         60: 'size-large'
        //                     };

		// 				// Loop through each element and set styles
		// 				elements.forEach(function(element) {
		// 					// element.style.height = event.data.split(': ')[1]; // Set height
		// 					// element.style.width = event.data.split(': ')[1]; // Set width
        //                     for (let x in size_class) {
        //                         if (x ===  event.data.split(': ')[1]) {
        //                             element.classList.add(size_class[x]);
        //                         }
        //                     }
		// 				});

		// 				// var sizeElements = document.querySelectorAll('.toolbox-icon svg:not(#participant-connection-indicator svg)'); //  > div > span > div

		// 						// Loop through each element and set styles
		// 			elements.forEach(function(element) {
		// 					// if (element.id != '#participant-connection-indicator')
		// 					// element.style.height = event.data.split(': ')[1]; // Set height
		// 					// element.style.width = event.data.split(': ')[1]; // Set width
        //                     for (let x in size_class) {
        //                         if (x ===  event.data.split(': ')[1]) {
        //                             element.classList.add(size_class[x]);
        //                         }
        //                     }
		// 				});
		// 			}
                
        // });
    

        // let video;
//         const video = document.getElementById('largeVideo');

//                 /* === 3) Detection helpers: mark pipReady when the first frame is available === */
// function armVideoReadyDetectors(videoEl, stream) {
//   function markReadyIfFrame() {
//     // Only mark ready if we have a real rendered frame size
//     if (videoEl.videoWidth && videoEl.videoHeight) {
//       pipReady = true;
//       console.log('PiP ready: video has dimensions', videoEl.videoWidth, videoEl.videoHeight);
//     }
//   }

//   // loadeddata fires when the first frame is available in many cases
//   videoEl.addEventListener('loadeddata', markReadyIfFrame, { once: true });

//   // resize fires when intrinsic size or decoded frames change (good for WebRTC)
//   videoEl.addEventListener('resize', markReadyIfFrame, { once: true });

//   // playing is fired when playback actually started
//   videoEl.addEventListener('playing', markReadyIfFrame, { once: true });

//   // For modern browsers, requestVideoFrameCallback is the most reliable way to detect first decoded frame
//   if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
//     try {
//       videoEl.requestVideoFrameCallback(() => { markReadyIfFrame(); });
//     } catch (e) { /* ignore */ }
//   }

//   // Tracks: if track unmute happens later, that's a good signal too
//   if (stream && stream.getVideoTracks) {
//     stream.getVideoTracks().forEach(track => {
//       const onUnmute = () => { markReadyIfFrame(); track.removeEventListener('unmute', onUnmute); };
//       track.addEventListener('unmute', onUnmute);
//     });
//   }

//   // Fallback: poll a few times for videoWidth (very defensive)
//   let tries = 0;
//   const poll = () => {
//     if (!pipReady && tries < 15) {
//       tries++;
//       markReadyIfFrame();
//       if (!pipReady) setTimeout(poll, 200);
//     }
//   };
//   poll();
// }



//     /* === 2) Attach stream and "pre-warm" the video === */
// function attachLocalStream(stream, videoEl) {
//   videoEl.srcObject = stream;

//   // Helpful properties for autoplay & PiP:
//   videoEl.playsInline = true;
//   videoEl.muted = true;        // mute so autoplay doesn't get blocked
//   videoEl.autoplay = true;
//   videoEl.controls = false;

//   // Try to start playback immediately to get the first frame decoding.
//   // We don't await here because awaiting before PiP can lose user activation
//   videoEl.play().catch(() => {
//     // play() can fail if no user gesture yet; detection below will still catch first-frame later
//   });

//   // Setup detectors to mark the video as "ready" for PiP as soon as we have a real frame.
//   armVideoReadyDetectors(videoEl, stream);
// }


//         let pipReady = false;


//         /* === 1) Start camera and attach stream to video === */
//         async function startCamera() {
//             try {
//                 localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
//                 attachLocalStream(localStream, video);
//             } catch (err) {
//                 console.error('getUserMedia failed:', err);
//                 alert('Camera access failed: ' + (err && err.message));
//             }
//         }

//         let localStream = null;

    //     window.addEventListener('message', async function (event) {
    //         // if (event.origin.indexOf('sidespeak') != -1) return;
    //         if (typeof event.data === 'string' && event.data.includes('pip-request')) {
    //             console.log('Picture-in-Picture request received! event.data is:', event.data);

    //             try {
    //                 let video;
    //                 video = document.getElementById('largeVideo');

    //                  // IMPORTANT: nothing async before this point
    //                 if (document.pictureInPictureElement) {
    //                     await document.exitPictureInPicture();
    //                     return;
    //                 } else {
    //                     // Make sure the video is loaded/playing. Don't await here before PiP.
    //                     if (video.paused) { video.play().catch(()=>{}); }
    //                     await video.requestPictureInPicture();
    //                 }

    //             } catch (err) {
    //                 console.log('Error listening for PiP:', err);
                    
    //             }

             
    // //                 try {
    // //                     // If camera not started, prompt/get it now (this is user gesture)
    // //                     if (!localStream) {
    // //                         await startCamera(); // user gesture active -> getUserMedia should show permission prompt
    // //                         // don't await anything else that would remove gesture before PiP call below
    // //                     }

              

    // //                 if (!pipReady) {
    // //                     // Optional: nudge playback once more; still no awaits before PiP.
    // //                     if (video.paused) video.play().catch(()=>{});
    // //                     }

    // //                       // If already in PiP, exit:
    // //                         if (document.pictureInPictureElement) {
    // //                         await document.exitPictureInPicture();
    // //                         return;
    // //                         }

    // //                    // Now attempt PiP. Browsers require this call to be done while handling a user gesture.
    // // // requestPictureInPicture() returns a Promise â€” awaiting it is fine here because we already
    // // // are inside the click handler (the gesture).
    // // await video.requestPictureInPicture();
    // // console.log('PiP entered successfully');
    // //             } catch (err) {
    // //                 console.error('PiP failed:', err);
    // //             }

    //             // if (video) 
    //             //     if (document.pictureInPictureElement === null) 
    //             //         await video.requestPictureInPicture()
    //             //         .then(() => console.log('PiP open request successful!')
    //             //         )
    //             //         .catch((err) => console.log('Error during requestPictureInPicture():', err)
    //             //         )
    //             //     else await document.exitPictureInPicture()
    //             //         .then(() => console.log('PiP exit request successful!')
    //             //         )
    //             //         .catch((err) => console.log('Error during exitPictureInPicture():', err)
    //             //         )
    //             // else console.log('Video element not recognized! Please make sure your camera video is turned on before trying PiP.');
                

    //         }
        
    //     })

    </script>
    <script><!--#include virtual="/config.js" --></script><!-- adapt to your needs, i.e. set hosts and bosh path -->
    <script><!--#include virtual="/interface_config.js" --></script>
    <script src="libs/lib-jitsi-meet.min.js?v=139"></script>
    <script src="libs/app.bundle.min.js?v=139"></script>
    <!--#include virtual="title.html" -->
    <!--#include virtual="plugin.head.html" -->
    <!--#include virtual="static/welcomePageAdditionalContent.html" -->
    <!--#include virtual="static/welcomePageAdditionalCard.html" -->
    <!--#include virtual="static/settingsToolbarAdditionalContent.html" -->
  </head>
  <body>
    <noscript aria-hidden="true">
        <div>JavaScript is disabled. </br>For this site to work you have to enable JavaScript.</div>
    </noscript>
    <!--#include virtual="body.html" -->
    <div id="react" role="main"></div>
  </body>
</html>
